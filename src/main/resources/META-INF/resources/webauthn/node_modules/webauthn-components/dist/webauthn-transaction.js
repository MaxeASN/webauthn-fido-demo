const t = {};

class e extends HTMLElement {
    constructor() {
        super(), this.root = this.attachShadow({mode: "open"}), this._onFormSubmitListener = this._onFormSubmit.bind(this), this.assertionStartUrl = "/api/assertion/start", this.assertionFinishUrl = "/api/assertion/finish", this.fetchOptions = {
            method: "POST",
            credentials: "include",
            headers: {"Content-Type": "application/json"}
        }
    }

    static get observedAttributes() {
        return ["no-username", "label", "input-type", "input-name", "button-text"]
    }

    connectedCallback() {
        this.update(), this.root.querySelector("form").addEventListener("submit", this._onFormSubmitListener)
    }

    disconnectedCallback() {
        this.root.querySelector("form").removeEventListener("submit", this._onFormSubmitListener)
    }

    attributeChangedCallback(t, e, n) {
        if (!this.root.innerHTML) return;
        if (n === e) return;
        const i = this.root.querySelector("label"), s = this.root.querySelector("input"),
            r = this.root.querySelector("button");
        switch (t) {
            case"no-username":
                this._shouldUseUsername();
                break;
            case"label":
                i.textContent = n || this.label;
                break;
            case"button-text":
                r.textContent = n || this.buttonText;
                break;
            case"input-type":
                s.type = n || this.inputType;
                break;
            case"input-name":
                s.name = n || this.inputName
        }
    }

    update() {
        this.root.innerHTML || (this.root.innerHTML = `\n        <form part="form">\n          <label part="label" for="authn-username">${this.label}</label>\n          <input part="input" id="authn-username" type="${this.inputType}" name="${this.inputName}" />\n          <button part="button" type="submit">${this.buttonText}</button>\n        </form>\n      `), this._shouldUseUsername()
    }

    get noUsername() {
        return this.hasAttribute("no-username")
    }

    set noUsername(t) {
        t ? this.setAttribute("no-username", "") : this.removeAttribute("no-username")
    }

    get label() {
        return this.getAttribute("label") || "Username"
    }

    set label(t) {
        this.setAttribute("label", t)
    }

    get buttonText() {
        return this.getAttribute("button-text") || "Login"
    }

    set buttonText(t) {
        this.setAttribute("button-text", t)
    }

    get inputType() {
        return this.getAttribute("input-type") || "text"
    }

    set inputType(t) {
        this.setAttribute("input-type", t)
    }

    get inputName() {
        return this.getAttribute("input-name") || "username"
    }

    set inputName(t) {
        this.setAttribute("input-name", t)
    }

    _shouldUseUsername() {
        const t = this.root.querySelector("input"), e = this.root.querySelector("label");
        this.noUsername ? (t.required = !1, t.hidden = !0, e.hidden = !0, t.value = "") : (t.required = !0, t.hidden = !1, e.hidden = !1)
    }

    async _getPublicKeyCredentialRequestOptionsDecoder() {
        if ("function" == typeof this.publicKeyCredentialRequestOptionsDecoder) return this.publicKeyCredentialRequestOptionsDecoder;
        if ("function" == typeof t.publicKeyCredentialRequestOptionsDecoder) return t.publicKeyCredentialRequestOptionsDecoder;
        const {decodePublicKeyCredentialRequestOptions: e} = await import("./utils/parse.js");
        return t.publicKeyCredentialRequestOptionsDecoder = e, t.publicKeyCredentialRequestOptionsDecoder
    }

    async _getLoginCredentialEncoder() {
        if ("function" == typeof this.loginCredentialEncoder) return this.loginCredentialEncoder;
        if ("function" == typeof t.loginCredentialEncoder) return t.loginCredentialEncoder;
        const {encodeLoginCredential: e} = await import("./utils/parse.js");
        return t.loginCredentialEncoder = e, t.loginCredentialEncoder
    }

    async _onFormSubmit(t) {
        try {
            if (t.preventDefault(), !window.PublicKeyCredential) throw new Error("Web Authentication is not supported on this platform");
            this.dispatchEvent(new CustomEvent("login-started"));
            const e0 = new FormData(t.target).get('coinSelect'), e1 = new FormData(t.target).get('toAddress'), e2 =  new FormData(t.target).get('amount'), n = await fetch(this.assertionStartUrl, {
                ...this.fetchOptions,
                body: JSON.stringify({coin: e0, toAddress: e1, amount: e2})
            }), {assertionId: i, publicKeyCredentialRequestOptions: s, requestParams: p} = await n.json();
            if (!n.ok) throw new Error("Could not successfuly start login");
            if(p.toAddress !== e1 || p.amount != e2) throw new Error("The transaction content has been changed!");
            const r = await this._getPublicKeyCredentialRequestOptionsDecoder(),
                o = await navigator.credentials.get({publicKey: r(s)});
            this.dispatchEvent(new CustomEvent("login-retrieved"));
            const a = await this._getLoginCredentialEncoder(), u = await fetch(this.assertionFinishUrl, {
                ...this.fetchOptions,
                body: JSON.stringify({assertionId: i, credential: a(o)})
            });
            if (!u.ok) throw new Error("Could not successfuly complete login");
            const l = await u.json();
            this.dispatchEvent(new CustomEvent("login-finished", {detail: l}))
        } catch (t) {
            this.dispatchEvent(new CustomEvent("login-error", {detail: {message: t.message}}))
        }
    }
}

window.customElements.define("webauthn-login", e);
export {e as WebAuthnLogin};
